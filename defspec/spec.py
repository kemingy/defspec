from __future__ import annotations

import inspect
import sys
from collections import defaultdict
from collections.abc import Callable
from typing import Any, Literal, Optional, Type, cast

import msgspec

from defspec.server import serve_openapi_http_daemon

if sys.version_info >= (3, 11):
    from typing import Self
else:
    from typing_extensions import Self


DEFAULT_CONTENT_TYPE = "application/json"


class OpenAPIInfo(msgspec.Struct, kw_only=True):
    title: str = "OpenAPI"
    description: str = "OpenAPI generated by defspec"
    version: str = "0.1.0"


class OpenAPIParam(msgspec.Struct, kw_only=True):
    name: str
    located_in: Literal["query", "header", "cookie"] = msgspec.field(
        default="query", name="in"
    )
    required: bool = True
    description: str = ""
    schema: dict[str, str]


class JSONSchema(msgspec.Struct, kw_only=True, omit_defaults=True):
    content: dict[str, dict] = msgspec.field(default_factory=dict)

    @classmethod
    def with_schema_content_type(
        cls, schema: dict[str, dict], content_type: Optional[str] = None
    ) -> Self:
        instance = cls()
        content_type = content_type or DEFAULT_CONTENT_TYPE
        if schema.get("type", "") != "null":
            instance.content[content_type] = {"schema": schema}
        return instance


class OpenAPIRequestBody(JSONSchema):
    pass


class OpenAPIResponse(JSONSchema):
    description: str = ""

    def __post_init__(self):
        """To avoid omitting description field."""
        if not self.description:
            self.description = "OK"


class OpenAPIRoute(msgspec.Struct, kw_only=True, omit_defaults=True):
    summary: str
    operation_id: str = msgspec.field(name="operationId")
    description: str = ""
    parameters: list[OpenAPIParam] = msgspec.field(default_factory=list)
    request_body: OpenAPIRequestBody = msgspec.field(name="requestBody")
    responses: dict[str, OpenAPIResponse]
    security: list[Any] = msgspec.field(default_factory=list)
    deprecated: bool = False


class OpenAPIComponent(msgspec.Struct, kw_only=True, omit_defaults=True):
    schemas: dict[str, dict]
    security_schemes: dict[str, dict] = msgspec.field(
        name="securitySchemes", default_factory=dict
    )


HTTP_METHODS = Literal[
    "get", "post", "put", "delete", "head", "options", "connect", "trace", "patch"
]


__MSGSPEC_STRUCT_DOC__ = inspect.getdoc(msgspec.Struct)


def get_def_doc(obj: Type) -> str:
    """Get the docstring of a type."""
    doc = inspect.getdoc(obj)
    if doc is None:
        return ""
    # `inspect.getdoc` will traverse the __mro__ of a type, so we need to check
    if doc == __MSGSPEC_STRUCT_DOC__:
        return ""
    return doc


class OpenAPI(msgspec.Struct, kw_only=True):
    """OpenAPI specification.

    Usage:
        openapi = OpenAPI()
        # init with customized info
        openapi = OpenAPI(info=OpenAPIInfo(title="My API", version="1.2.3"))
    """

    openapi: str = "3.1.0"
    info: OpenAPIInfo = msgspec.field(default_factory=OpenAPIInfo)
    paths: dict[str, dict[str, OpenAPIRoute]] = msgspec.field(
        default_factory=lambda: defaultdict(dict)
    )
    defs: dict[str, dict] = msgspec.field(name="$defs", default_factory=dict)

    def register_route(
        self,
        path: str,
        method: HTTP_METHODS,
        summary: Optional[str] = None,
        request_type: Optional[Type] = None,
        request_content_type: Optional[str] = None,
        response_type: Optional[Type] = None,
        response_content_type: Optional[str] = None,
        query_type: Optional[Type] = None,
        header_type: Optional[Type] = None,
        cookie_type: Optional[Type] = None,
        deprecated: bool = False,
        schema_hook: Optional[Callable[[type], dict[str, Any]]] = None,
    ):
        """Register a route to OpenAPI specification.

        Args:
            path: path of the route
            method: HTTP method of the route
            summary: summary of the route
            request_type: type of the request body
            request_content_type: `Content-Type` of the request body
            response_type: type of the response body
            response_content_type: `Content-Type` of the response body
            query_type: type of the query parameters
            header_type: type of the header parameters
            cookie_type: type of the cookie parameters
            deprecated: whether the route is deprecated
            schema_hook: a callable that takes a type and returns a dict for
                custom schema generation
        """
        request_schema = msgspec.json.schema(request_type, schema_hook=schema_hook)
        response_schema = msgspec.json.schema(response_type, schema_hook=schema_hook)

        self.defs.update(request_schema.pop("$defs", {}))
        self.defs.update(response_schema.pop("$defs", {}))

        self.paths[path][method] = OpenAPIRoute(
            summary=summary or f"{method} from {path.replace('/', ' ')}",
            operation_id=f"{method}_{path.replace('/', '_')}",
            request_body=OpenAPIRequestBody.with_schema_content_type(
                request_schema, request_content_type
            ),
            responses={
                "200": OpenAPIResponse.with_schema_content_type(
                    response_schema, response_content_type
                )
            },
            deprecated=deprecated,
        )

        for param_location, param_type in [
            ("query", query_type),
            ("header", header_type),
            ("cookie", cookie_type),
        ]:
            if param_type is None:
                continue
            schema = msgspec.json.schema(param_type, schema_hook=schema_hook)
            self.defs.update(schema.pop("$defs", {}))
            self.paths[path][method].parameters.append(
                OpenAPIParam(
                    name=param_type.__name__,
                    located_in=cast(
                        Literal["query", "header", "cookie"], param_location
                    ),
                    schema=schema,
                    description=get_def_doc(param_type),
                )
            )

    def to_json(self) -> bytes:
        """Convert to a JSON bytes that is commonly used in HTTP endpoint."""
        return msgspec.json.encode(self)

    def to_dict(self) -> dict:
        """Convert to a dict."""
        return msgspec.to_builtins(self)

    def serve_as_http_daemon(
        self, host: str = "127.0.0.1", port: int = 8080, run_in_background: bool = False
    ):
        """Serve the OpenAPI specification and UI as a HTTP server.

        - `/openapi/spec.json`: the OpenAPI specification
        - `/openapi/swagger`: the Swagger UI
        - `/openapi/redoc`: the ReDoc UI
        - `/openapi/scalar`: the Scalar UI

        Args:
            host: host to serve
            port: port to serve
            run_in_background: whether to run in a daemon thread
        """
        serve_openapi_http_daemon(host, port, run_in_background, self.to_json())
